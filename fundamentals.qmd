---
lightbox: true
filters: 
  - line-highlight
---

# Fundamentals

## Learning Objectives {.unnumbered .objectives}

Use the Shiny framework to develop online interactive applications accepting user input to render outputs from arbitrary R functions.

## Install packages

Let's begin by installing and loading the packages used for this workshop. This will already be installed if you're using [Posit Cloud](#sec-cloud).

```{r}
#| eval: false
install.packages(c('shiny', 'tidyverse'))
library(shiny)
library(tidyverse)
```

## A simple example

We'll start with a simple application of Shiny.  As with most problems, it's good to start with identifying where you want to go and then work backwards to figure out how to get there.  Let's end with a simple histogram to visualize some data for the normal distribution, but with different sample sizes.  To start, we create the simple plot with the random data of a given sample size. 

```{r}
dat <- rnorm(100)
hist(dat)
```

Changing the sample size:

```{r}
dat <- rnorm(10)
hist(dat)
```

To make a Shiny app out of this, we need to identify our inputs and outputs.  The input in this case is what we want to be able to modify (the sample size) and the output is the plot.  This can all be done in a single script by creating a `ui` and `server` component.  Inputs and outputs go in the `ui` object.  The `server` takes the inputs, does something with them, then sends the results back to the `ui`. 

Using our template from before: 

```{r}
#| eval: false
library(shiny)
ui <- fluidPage()
server <- function(input, output){}
shinyApp(ui = ui, server = server)
```

Then putting this into our template would look something like this: 

```{r}
#| eval: false
library(shiny)

ui <- fluidPage(
  numericInput(inputId = 'n', label = 'Sample size', value = 50),
  plotOutput('myplot')
)

server <- function(input, output){
  output$myplot <- renderPlot({
    dat <- rnorm(input$n)
    hist(dat)
  })
}

shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/histshiny.png)

Okay, so what is happening under the hood when you change the sample size?  

1.  The `input` value `n` (you name it) for the `server` is chosen by the user from the `ui`.  This uses the `numericInput()` widget.

    ```{r}
    #| eval: false
    #| source-line-numbers: "2"
    ui <- fluidPage(
      numericInput(inputId = 'n', label = 'Sample size', value = 50),
      plotOutput('myplot')
    )
    ```
    
1.  Shiny recognizes that the `input$n` value comes from the `ui` and is used by the `server` to create the random sample `dat`.

    ```{r}
    #| eval: false
    #| source-line-numbers: "3"
    server <- function(input, output){
      output$myplot <- renderPlot({
        dat <- rnorm(input$n)
        hist(dat)
      })
    }
    ```

1.  The `dat` object with sample size `n` is then used to create a histogram.

    ```{r}
    #| eval: false
    #| source-line-numbers: "4"
    server <- function(input, output){
      output$myplot <- renderPlot({
        dat <- rnorm(input$n)
        hist(dat)
      })
    }
    ```
    
1.  The plot output named `myplot` (you name it) is created using the `renderPlot()` function and appended to the `output` list of objects in the `server` function.

    ```{r}
    #| eval: false
    #| source-line-numbers: "2"
    server <- function(input, output){
      output$myplot <- renderPlot({
        dat <- rnorm(input$n)
        hist(dat)
      })
    }
    ```

1.  The plot is then rendered on the `ui` using `plotOutput` by referencing the `myplot` name from the `output` object 

    ```{r}
    #| eval: false
    #| source-line-numbers: "3"
    ui <- fluidPage(
      numericInput(inputId = 'n', label = 'Sample size', value = 50),
      plotOutput('myplot')
    )
    ```

This is what it looks like in a simple flowchart.

![](figs/fundamentals/simpleappflo.png)

All of this happens each time the input values are changed, such that the output __reacts__ to any change in the input. This is a fundamental principle of Shiny reactivity, simplified as follows.

![](figs/fundamentals/flow.png){width=50% fig-align="center"}

## Using the RStudio template

Another useful way of learning the basics of the `ui` and `server` is to use the built-in Shiny template in RStudio. Under **File** -> **New File** -> **Shiny Web App...**, you can open a script that has a working Shiny app.  Tinkering with this file will teach you a lot about how Shiny works.    

For now, let's go with the single file option that puts the entire application in `app.R` rather than splitting it intwo (`ui.R`, `server.R`).

![](figs/fundamentals/new-shiny-app.png){width="400"}

Let's try it again from scratch, recreating our simple histogram example.  Here's what the template file looks like: 

```{r}
#| eval: false
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    https://shiny.posit.co/
#

library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("Old Faithful Geyser Data"),

    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            sliderInput("bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    output$distPlot <- renderPlot({
        # generate bins based on input$bins from ui.R
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)

        # draw the histogram with the specified number of bins
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/faithfulshiny.png)

We can replace the relevant pieces with those used in our initial histogram app. What does this app do differently from the original? 

Your final product should look like this: 

```{r}
#| eval: false
library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("My awesome histogram app"),

    # Sidebar with a numeric input for sample size 
    sidebarLayout(
        sidebarPanel(
           numericInput(inputId = 'n', label = 'Sample size', value = 50)
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    output$distPlot <- renderPlot({
        
      # generate random sample of size n
        x <- rnorm(input$n)

        # draw the histogram
        hist(x)
        
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/histshinytemplate.png)

This is the same app as before, but the layout is different and we've only replaced the relevant pieces, i.e., the title, the numeric input widget, and a simpler plot.  

Let's spice it up by adding a widget for changing the histogram color. There's a lot to say about "widgets" - Shiny has many you can choose from depending on the type of input you need.  [This page](https://shiny.posit.co/r/gallery/widgets/widget-gallery/){target="_blank"} provides an overview of available widgets.  We'll add the `selectInput()` widget in this example.

```{r}
#| eval: false
library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("My awesome histogram app"),

    # Sidebar with a numeric input for sample size 
    sidebarLayout(
        sidebarPanel(
           numericInput(inputId = 'n', label = 'Sample size', value = 50), 
           selectInput(inputId = 'col', label = 'Choose color', choices = c('red', 'blue', 'green'))
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    output$distPlot <- renderPlot({
        
      # generate random sample of size n
        x <- rnorm(input$n)

        # draw the histogram
        hist(x, col = input$col)
        
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/histshinytemplatecol.png)

Notice how the random sample changes when you update the color.  Why is that? How can we fix this? 

## Showcase mode

A useful tool provided by Shiny is running an application in showcase mode.  This is a literal demonstration of the workflow outlined above, but in realtime as you run the app.  To use showcase mode, you must first save your app as an R script in a folder of the same name (`app`). Use the function `shiny::runApp()` and add `display.mode = 'showcase'` in the call.

```{r}
#| eval: false
shiny::runApp('app', display.mode = 'showcase')
```

![](figs/fundamentals/showcase.png)

This is a simple example that isn't very informative, but it gives you a sense of how showcase made works.  It will be more useful with a more complex app. 

## Debugging a Shiny app

Figuring out why and where your code might break in an application is challenging because of the reactivity inherent in a Shiny app. You can't just run the app step by step as you would a normal R script. The `browser()` function can be used to "step inside" the R code of an app. The `browser()` function can work with any arbitrary R function that is part of your environment.  We'll first demonstrate how to use it with a simple function.

```{r}
my_func <- function(n){

  x <- rnorm(n)
  hist(x)
  
}
my_func(n)
```

Let's save this code in a new R script, place the `browser()` function inside of `my_func()`, and run the code again.

```{r}
#| eval: false
my_func <- function(n){

  browser()
  x <- rnorm(n)
  hist(x)
  
}
my_func(n)
```

Two things happen when the code is run: 

1.  The source code now highlights the `browser()` function with a green arrow.  This indicates your current location inside the browser.

    ![](figs/fundamentals/browsersource.png){width=50% fig-align="center"}

1.  The console will show that you're in the browser.

    ![](figs/fundamentals/browserconsole.png){width=50% fig-align="center"}
    
1.  Browser controls appear at the top of the console.

    ![](figs/fundamentals/browsercontrols.png){width=50% fig-align="center"}
    
You can now "step" through the function using these controls or by pressing "enter".  The code will run as intended if there are no errors.  You will exit the browser once the code execution is complete or if you hit the "Stop" button on the controls. Any objects created inside the function will be available for you to investigate if there are issues.

The `browser()` works the same with a Shiny app.  You'll use it within objects in the `server` component since these behave as functions. For example:

```{r}
#| eval: false
# Define server logic required to draw a histogram
server <- function(input, output) {
  
  output$distPlot <- renderPlot({
    browser()
    # generate random sample of size n
    x <- rnorm(input$n)
    
    # draw the histogram
    hist(x, col = input$col)
    
  })
}
```

The browser takes a bit of practice to get comfortable, but you'll quickly find it a useful tool for debugging apps, particularly those that have multiple working parts. 

## A better example

Now that we know the basics of a Shiny app and how to debug basic components, we'll create a more involved example similar to one you may encounter with water quality data. 

## A dirty trick...

Much has changed in the programming world over the last few years.  As you might expect, there are generative AI tools to help build and develop Shiny apps.  