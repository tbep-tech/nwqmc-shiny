---
lightbox: true
filters: 
  - line-highlight
---

# Fundamentals

## Learning Objectives {.unnumbered .objectives}

Use the Shiny framework to develop online interactive applications accepting user input to render outputs from arbitrary R functions.

## Install packages

Let's begin by installing and loading the packages used for this workshop. This will already be installed if you're using [Posit Cloud](#sec-cloud).

```{r}
#| eval: false
install.packages(c('shiny', 'tidyverse'))
library(shiny)
library(tidyverse)
```

## A simple example

We'll start with a simple application of Shiny.  As with most problems, it's good to start with identifying where you want to go and then work backwards to figure out how to get there.  Let's end with a simple histogram to visualize some data for the normal distribution, but with different sample sizes. 

```{r}
dat <- rnorm(100)
hist(dat)
```

Changing the sample size:

```{r}
dat <- rnorm(10)
hist(dat)
```

To make a Shiny app out of this, we need to identify our inputs and outputs.  The input in this case is what we want to be able to modify (the sample size) and the output is the plot.  This can all be done in a single script by creating a `ui` and `server` component.  Inputs and outputs go in the `ui` object.  The `server` takes the inputs, does something with them, then sends the results back to the `ui`. 

Using our template from before: 

```{r}
#| eval: false
library(shiny)
ui <- fluidPage()
server <- function(input, output){}
shinyApp(ui = ui, server = server)
```

Then putting this into our template would look something like this: 

```{r}
#| eval: false
library(shiny)

ui <- fluidPage(
  numericInput(inputId = 'n', label = 'Sample size', value = 50),
  plotOutput('myplot')
)

server <- function(input, output){
  output$myplot <- renderPlot({
    dat <- rnorm(input$n)
    hist(dat)
  })
}

shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/histshiny.png)

Okay, so what is happening under the hood when you change the sample size?  

1. The `input` value `n` (you name it) is chosen by the user from the `ui`.

```{r}
#| eval: false
#| source-line-numbers: "2"
ui <- fluidPage(
  numericInput(inputId = 'n', label = 'Sample size', value = 50),
  plotOutput('myplot')
)
```
    
2. Shiny recognizes that the `input$n` value has changed and re-runs any pieces of `server` that use that value.   
```{r}
#| eval: false
#| source-line-numbers: "3"
server <- function(input, output){
  output$myplot <- renderPlot({
    dat <- rnorm(input$n)
    hist(dat)
  })
}
```

3. The `dat` object is created as a random sample with size `n` and then a histogram is created as reactive output with `renderPlot`

```{r}
#| eval: false
#| source-line-numbers: "4"
server <- function(input, output){
  output$myplot <- renderPlot({
    dat <- rnorm(input$n)
    hist(dat)
  })
}
```
    
4. The plot output named `myplot` (you name it) is appended to the `output` list of objects in the `server` function

```{r}
#| eval: false
#| source-line-numbers: "2"
server <- function(input, output){
  output$myplot <- renderPlot({
    dat <- rnorm(input$n)
    hist(dat)
  })
}
```

5. The plot is then rendered on the `ui` using `plotOutput` by referencing the `myplot` name from the `output` object 

```{r}
#| eval: false
#| source-line-numbers: "3"
ui <- fluidPage(
  numericInput(inputId = 'n', label = 'Sample size', value = 50),
  plotOutput('myplot')
)
```

![](figs/fundamentals/simpleappflo.png)

All of this happens each time the input values are changed, such that the output __reacts__ to any change in the input. This is a fundamental principle of Shiny reactivity, simplified as follows.

![](figs/fundamentals/flow.png){width=50% fig-align="center"}

## Using the RStudio template

Another useful way of learning the basics of the `ui` and `server` is to use the built-in Shiny template in RStudio. Under **File** -> **New File** -> **Shiny Web App...**, you can open a script that has a working Shiny app.  Tinkering with this file will teach you a lot about how Shiny works.    

For now, let's go with the single file option that puts the entire application in `app.R` rather than splitting it intwo (`ui.R`, `server.R`).

![](figs/fundamentals/new-shiny-app.png){width="400"}

Let's try it again from scratch, recreating our simple histogram example.  Here's what the template file looks like: 

```{r}
#| eval: false
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    https://shiny.posit.co/
#

library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("Old Faithful Geyser Data"),

    # Sidebar with a slider input for number of bins 
    sidebarLayout(
        sidebarPanel(
            sliderInput("bins",
                        "Number of bins:",
                        min = 1,
                        max = 50,
                        value = 30)
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    output$distPlot <- renderPlot({
        # generate bins based on input$bins from ui.R
        x    <- faithful[, 2]
        bins <- seq(min(x), max(x), length.out = input$bins + 1)

        # draw the histogram with the specified number of bins
        hist(x, breaks = bins, col = 'darkgray', border = 'white',
             xlab = 'Waiting time to next eruption (in mins)',
             main = 'Histogram of waiting times')
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/faithfulshiny.png)

We can replace the relevant pieces with those used in our initial histogram app.Your final product should look like this: 

```{r}
#| eval: false
library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("My awesome histogram app"),

    # Sidebar with a numeric input for sample size 
    sidebarLayout(
        sidebarPanel(
           numericInput(inputId = 'n', label = 'Sample size', value = 50)
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    output$distPlot <- renderPlot({
        
      # generate random sample of size n
        x <- rnorm(input$n)

        # draw the histogram
        hist(x)
        
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/histshinytemplate.png)

This is the same app as before, but the layout is different and we've only replaced the relevant pieces, i.e., the title, the numeric input widget, and a simpler plot.  

Let's spice it up by adding a widget for changing the histogram color. There's a lot to say about "widgets" - Shiny has many you can choose from depending on the type of input you need.  [This page](https://shiny.posit.co/r/gallery/widgets/widget-gallery/){target="_blank"} provides an overview of available widgets.  We'll add the `selectInput()` widget in this example.

```{r}
#| eval: false
library(shiny)

# Define UI for application that draws a histogram
ui <- fluidPage(

    # Application title
    titlePanel("My awesome histogram app"),

    # Sidebar with a numeric input for sample size 
    sidebarLayout(
        sidebarPanel(
           numericInput(inputId = 'n', label = 'Sample size', value = 50), 
           selectInput(inputId = 'col', label = 'Choose color', choices = c('red', 'blue', 'green'))
        ),

        # Show a plot of the generated distribution
        mainPanel(
           plotOutput("distPlot")
        )
    )
)

# Define server logic required to draw a histogram
server <- function(input, output) {

    output$distPlot <- renderPlot({
        
      # generate random sample of size n
        x <- rnorm(input$n)

        # draw the histogram
        hist(x, col = input$col)
        
    })
}

# Run the application 
shinyApp(ui = ui, server = server)
```

![](figs/fundamentals/histshinytemplatecol.png)

Notice how the random sample changes when you update the color.  Why is that? How can we fix this? 

## Showcase mode

A useful tool provided by Shiny is running an application in showcase mode.  This is a literal demonstration of the workflow outlined above, but in realtime as you run the app.  To use showcase mode, you must first save your app as an R script in a folder of the same name. Use the function `shiny::runApp()` and add `display.mode = 'showcase'` in the call.

```{r}
#| eval: false
shiny::runApp('app', display.mode = 'showcase')
```

![](figs/fundamentals/showcase.png)

This is a simple example that isn't very informative, but it gives you a sense of how showcase made works.  It will be more useful with a more complex app. 

## Debugging a Shiny app

`browser()`

## A better example

Water quality time series

## A dirty trick...

Much has changed in the programming world over the last few years.  As you might expect, there are generative AI tools to help build and develop Shiny apps.  